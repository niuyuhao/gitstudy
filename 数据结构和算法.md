# 数据结构和算法概述

## 线性结构和非线性结构

程序 = 数据结构+算法。

数据结构包括线性结构和非线性结构。

**线性结构**

特点：数据元素之间存在**一对一**的线性关系

两种存储结构：

​		顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表

中的**存储元素是连续的。**

​		链式存储的线性表称为链表，链表中的存储元素**不一定是连续**的，元素节点中存放数据元素以及相邻元素的地址信息。

常见的：数组、队列、链表和栈。

**非线性结构**

二维数组，多维数组，广义表，树结构，图结构

### 稀疏数组和队列

#### 稀疏数组

应用场景：

![image-20210921213428166](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210921213428166.png)



基本介绍：

​	当一个数组中**大部分元素为0，或者为同一个值的数组**时，可以使用稀疏数组来保存该数组。

​	处理方法：

​	1.记录数组**一共有几行几列，有多少个不同的值**

​	2.把具有不同值的元素的行列及值记录在一个**小规模的数组**中，从而缩小程序的规模。

![image-20210921213220456](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210921213220456.png)

应用实例：

​	1.使用稀疏数组，来保留类似前面的二维数组（棋盘、地图等等）

​	2.把稀疏数组存盘，并且可以从新恢复原来的二维数组

​	3.整体思路分析

![image-20210921220617852](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210921220617852.png)

​		二维数组转稀疏数组的思路：

​				a.遍历原始的二维数组，得到有效数据的个数sum

​				b.根据sum就可以创建稀疏数组sparseArr int[[sum+1]][][3]

​				c.将二维数组的有效数据存入到稀疏数组

​		稀疏数组转原始的二维数组的思路

​				a.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 

```java
chessArr2 = int[11][11]
```

​				b.在读取稀疏数组后几行的数据，并赋给原始的二维数组即可。

​	4.代码实现：

```java
public class SparseArray {
    public static void main(String[] args) {
        int[][] chessArr = new int[11][11];
        // 1代表一个黑子 2代表一个蓝子
        chessArr[1][2] = 1;
        chessArr[2][3] = 2;

        int sum = 0;
        // 遍历二维数组，找出有效数组个数
        for (int[] row : chessArr){
            for (int val:row){
                if (val!=0){
                    sum++;
                }
                System.out.printf("%d\t",val);
            }
            System.out.println();
        }
        //创建对应的稀疏数组 行  列  有效数据个数
        int[][] sparseArr = new int[sum+1][3];
        // 给稀疏数组赋值
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;
        int count = 0; //记录稀疏数组的行数（是第几个非0数组）
        //遍历二维数组，将非零的值存放到sparseArr中
        for (int i = 0; i < chessArr.length; i++) {
            for (int j = 0; j < chessArr[i].length; j++) {
                if (chessArr[i][j]!=0){
                    count++;//从第二行开始
                    sparseArr[count][0] = i;  //第i行
                    sparseArr[count][1] = j;  //第j列
                    sparseArr[count][2] = chessArr[i][j];
                }
            }
        }
        System.out.println("row\tcol\tval");
        for (int[] row :sparseArr){
            for (int val : row){
                System.out.printf("%d\t",val);
            }
            System.out.println();
        }
        //将稀疏数组恢复成二维数组
        System.out.println("恢复后的二维数组");
        int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];
        for (int i = count; i > 0; i--) {
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }
        for (int[] row : chessArr2){
            for (int val:row){
                if (val!=0){
                    sum++;
                }
                System.out.printf("%d\t",val);
            }
            System.out.println();
        }
    }
}
```

持久化存储

```java
import java.io.*;

/**
 *  课后练习：
 *  在前面的基础上，将稀疏数组保存到磁盘上，比如map.data
 *  恢复原来的数组时，读取map.data进行恢复
 */
public class Test {
    public static void main(String[] args) throws Exception {
        int[][] chessArr = initChess(11, 11);
        chessArr[1][2] = 1;
        chessArr[2][3] = 2;
        int[][] sparseArr = trans(chessArr);//转成稀疏数组
        res(sparseArr);
    }


    public static int[][] initChess(int row,int column){
        int[][] chessArr1 = new int[row][column];
        return chessArr1;
    }
    public static int[][] trans(int[][] arr) throws IOException {
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream("./map.data")));
        int sum = 0;
        int row = 0;
        int col = 0;
        // 遍历二维数组，找出有效数组的个数
        for (row = 0; row < arr.length; row++) {
            for (col = 0; col < arr[row].length; col++) {
                if (arr[row][col]!=0){
                    sum++;
                }
            }
        }
        //创建对应的稀疏数组
        int[][] sparseArr = new int[sum+1][3];
        //给稀疏数组赋值
        sparseArr[0][0] = row;
        sparseArr[0][1] = col;
        sparseArr[0][2] = sum;
        int c = 1;
        // 遍历二维数组,给稀疏数组赋值
        for (row = 0; row < arr.length; row++) {
            for (col = 0; col < arr[row].length; col++) {
                if (arr[row][col]!=0){
                    sparseArr[c][0] = row;
                    sparseArr[c][1] = col;
                    sparseArr[c][2] = arr[row][col];
                    c++;
                }
            }
        }
        System.out.println("row\tcol\tval");
        for (int i = 0; i < sparseArr.length; i++) {
            bw.write(sparseArr[i][0]+"##"+sparseArr[i][1]+"##"+sparseArr[i][2]+"@@");
            System.out.printf("%d\t%d\t%d\n",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);
        }
        bw.close();
        return sparseArr;
    }
    private static int[][] res(int[][] ints) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(
                new FileInputStream("./map.data")));
        //拆分
        String[] val = br.readLine().split("@@");
        //用来存储读出来的数据
        int count = ints[0][2];
        int[][] values = new int[count+1][3];
        String[] firstRow = val[0].split("##");
        values[0][0] = Integer.parseInt(firstRow[0]);
        values[0][1] = Integer.parseInt(firstRow[1]);
        values[0][2] = Integer.parseInt(firstRow[2]);

        int[][] chessArr = new int[values[0][0]][values[0][1]];
        for (int i = 1; i < val.length; i++) {
            //再次拆分
            String[] num = val[i].split("##");
            values[i][0] = Integer.parseInt(num[0]); //行
            values[i][1] = Integer.parseInt(num[1]); //列
            values[i][2] = Integer.parseInt(num[2]); //具体值

            chessArr[values[i][0]][values[i][1]] = values[i][2];
        }
        for (int[] row :chessArr){
            for (int num:row){
                System.out.printf("%d\t",num);
            }
            System.out.println();
        }
        br.close();
        return chessArr;
    }
}
```

#### 队列

队列是一个有序列表，可以用**数组**或是**链表**来实现。

**遵循先入先出的原则。**

数组模拟队列：

队列本身是有序列表，若使用数组的结构来存储队列，则队列数组的声明如下图，其中maxSize是该队列的最大容量。

因为队列的输出、输入是分别从前后端来处理，因此需要两个**变量front及rear分别记录队列前后端**的下标，front会随着数据输出而改变，而rear则是随着数据输入而改变，如图：

![image-20210922155914683](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210922155914683.png)

将数据存入队列时称为“addQueue”，addQueue的处理需要有两个步骤：**思路分析**

1. 将尾指针往后移rear+1，当front == rear【空】
2. 若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear==maxSize-1【队列满】

代码实现：

```java
public class ArrayQueue {
    public static void main(String[] args) {
        //测试
        ArrayQue que = new ArrayQue(3);
        char key = ' ';//用来接收用户输入
        Scanner scanner = new Scanner(System.in);
        boolean flg = true;

        //输出一个菜单
        while (flg){
            System.out.println("s(show):显示队列");
            System.out.println("e(exit):退出程序");
            System.out.println("a(add):添加数据到队列");
            System.out.println("g(get):从队列取出数据");
            System.out.println("h(head):查看队列头的数据");
            key = scanner.next().charAt(0);//接收一个字符
            switch (key){
                case 'a':
                    System.out.println("请输入要添加的数据");
                    que.addQueue(scanner.nextInt());
                    break;
                case 'e':
                    scanner.close();
                    flg = false;
                    break;
                case 'g':
                    System.out.println("取出的元素是"+que.getQueue());
                    break;
                case 'h':
                    System.out.println("当前的头部元素是"+que.showHead());
                    break;
                case 's':
                    que.showQueue();
                    break;
                default:
                    System.out.println("请输入正确格式");
                    break;
            }
        }
    }
}
class ArrayQue{
    private int maxSize;//数组最大容量
    private int front;//队列头
    private int rear;//队列尾
    private int[] arr;// 存放数据，模拟队列

    //创建队列的构造方法
    public ArrayQue(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1; //指向队列头部数据，一开始都在队列头部的前一个位置
        rear = -1; //指向队列尾的数据（即就是队列的最后一个数据）
    }
    //判断队列是否满
    public boolean isFull(){
        return rear==maxSize - 1;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return rear==front;
    }
    //进队列
    public void addQueue(int n){
        if (isFull()){
            throw new RuntimeException("队列已满");
        }
        rear++; //尾指针后移
        arr[rear] = n;
    }
    //出队列
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列以空");
        }
        front++; //头指针后移
        return arr[front];
    }
    //显示队列的所有数据
    public void showQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空，没有数据");
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n",i,arr[i]);
        }
    }
    //显示队列的头数据
    public int showHead(){
        if(isEmpty()){
            throw new RuntimeException("队列以空，没有数据");
        }
        return arr[front+1];
    }
}
```

问题分析并优化

1. 目前数组使用一次就不能用，没有达到复用的效果
2. 将这个数组使用算法改进成一个环形的队列  取模：%

**使用数组模拟环形队列的思路分析**

1. front变量的含义做一个调整：front就指向队列的第一个元素，也即是说arr[front]就是队列的第一个元素front初始值=0
2. rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置。**因为希望空出一个空间作为约定** rear的初始值=0
3. 队列为满时：(rear + 1)%maxSize == front【满】
4. 队列为空的条件：rear==front
5. 当我们这样分析，队列中有效的数据个数(rear+maxSize - front)%maxSize  //rear = 1    front = 0
6. 就可以在原来的队列上修改得到一个环形队列

![image-20210922173015707](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210922173015707.png)

```java
public class CircleArrayQueue {
    public static void main(String[] args) {

        //创建一个环形队列
        CircleArray cir = new CircleArray(4);
        char key = ' '; //用来接收用户输入
        Scanner scanner = new Scanner(System.in);
        boolean flg = true;

        //输出一个菜单
        while (flg){
            System.out.println("s(show):显示队列");
            System.out.println("e(exit):退出程序");
            System.out.println("a(add):添加数据到队列");
            System.out.println("g(get):从队列取出数据");
            System.out.println("h(head):查看队列头的数据");
            key = scanner.next().charAt(0);//接收一个字符
            switch (key){
                case 'a':
                    System.out.println("请输入要添加的数据");
                    cir.addQueue(scanner.nextInt());
                    break;
                case 'e':
                    scanner.close();
                    flg = false;
                    break;
                case 'g':
                    System.out.println("取出的元素是"+cir.getQueue());
                    break;
                case 'h':
                    System.out.println("当前的头部元素是"+cir.showHead());
                    break;
                case 's':
                    cir.showQueue();
                    break;
                default:
                    System.out.println("请输入正确格式");
                    break;
            }
        }
    }
}
class CircleArray{
    private int maxSize;//数组最大容量
    //front就指向队列的第一个元素，也即是说arr[front]就是队列的第一个元素
    // front初始值=0
    private int front;
    //rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置。因为希望空出一个空间作为约定
    // rear的初始值=0
    private int rear;//队列尾
    private int[] arr;// 存放数据，模拟队列

    //创建队列的构造方法
    public CircleArray(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
    }
    //判断队列是否满
    public boolean isFull(){
        return (rear + 1)%maxSize == front;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return rear==front;
    }
    //进队列
    public void addQueue(int n){
        if (isFull()){
            throw new RuntimeException("队列已满");
        }
        arr[rear] = n;
        // 将rear后移，这里必须考虑取模
        rear=(rear+1) % maxSize;
    }
    //出队列
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列以空");
        }
        // 这里需要分析出front是指向队列的第一个元素
        // 1.先把front 对应的值保留到一个临时变量
        // 2.将front 后移，考虑取模
        // 3.把临时保存的变量返回
        int value = arr[front];
        front = (front+1)%maxSize;
        return value;
    }
    //显示队列的所有数据
    public void showQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空，没有数据");
        }
        // 思路：从front开始遍历，遍历多少个元素
        for (int i = 0; i < front + size(); i++) {
            System.out.printf("arr[%d]=%d\n",i % maxSize,arr[i%maxSize]);
        }
    }
    public int size(){


        return (rear+maxSize - front)%maxSize;
    }
    //显示队列的头数据
    public int showHead(){
        if(isEmpty()){
            throw new RuntimeException("队列以空，没有数据");
        }
        return arr[front];
    }
}
```

### 链表

链表是有序的列表

1. 链表是以节点的方式来存储，是链式存储
2. 每个节点包含data域，next域：指向下一个节点
3. 链表的各个节点不一定是连续存储的
4. 链表分带头节点的链表和没有头节点的链表，根据实际需求来确定

![image-20210923103555420](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210923103555420.png)

#### 单链表的应用实例

使用带head头的单项链表实现-水浒英雄排行榜完成对人物的增删改

1. 第一种方法在添加英雄时，直接添加到链表的尾部

思路分析

<img src="C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210923153803660.png" alt="image-20210923153803660" style="zoom:67%;" />

   2.第二种方式，根据排名将英雄人物插入到指定位置（如果已经存在，提示添加失败）

<img src="C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210923153846763.png" alt="image-20210923153846763" style="zoom:67%;" />

​	3.修改节点

​		通过遍历	先找到该节点； 修改

​	4.删除节点

​		<img src="C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210923154048756.png" alt="image-20210923154048756" style="zoom:67%;" />

```java
public class SingleLinkedList {
    public static void main(String[] args) {
        HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
        HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");

        LinkedList linkedList = new LinkedList();
//        linkedList.add(hero1);
//        linkedList.add(hero2);
//        linkedList.add(hero3);
//        linkedList.add(hero4);
        linkedList.addByOrder(hero4);
        linkedList.addByOrder(hero3);
        linkedList.addByOrder(hero2);
        linkedList.addByOrder(hero1);

        linkedList.list();
        //测试修改节点的代码
//        HeroNode newHeroNode = new HeroNode(1,"送姜","及时雨");
//        linkedList.update(newHeroNode);
//        linkedList.list();

        linkedList.delete(2);
    }
}
class LinkedList{
    //先初始化一个头节点，头节点不要动，不放具体的数据
    private HeroNode head = new HeroNode(0,"","");

    //添加节点到单向链表
    //思路  当不考虑编号顺序时
    //1.找到当前链表的最后节点
    //2.将最后这个节点的next 指向新的节点
    public void add(HeroNode heroNode){
        //因为head节点不能动，所以需要一个辅助变量temp
        HeroNode temp = head;
        //遍历链表，找到最后
        while (true){
            //找到链表的最后
            if (temp.next==null){
                break;
            }
            //如果没有找到最后，将temp后移
            temp = temp.next;
        }
        //当退出while循环时，temp就指向了链表的最后
        //将最后这个节点的next  指向 新的节点
        temp.next = heroNode;
    }
    //第二种添加英雄的方式 ，根据排名插入指定位置
    //（如果有这个排名，则添加失败，给出提示）
    public void addByOrder(HeroNode heroNode){
        //因为头节点不能动，因此需要一个辅助指针来帮助找到添加的位置
        //因为单链表，所以我们找的temp是位于添加位置的前一个节点，否则插入不了
        HeroNode temp = head;
        boolean flag = false;  //用来判断添加的节点是否存在，默认false
        while (true){
            if (temp.next==null){  //说明temp已经在链表的最后了
                break;
            }
            if (temp.next.no > heroNode.no){ //位置找到
                break;
            }
            if (temp.next.no == heroNode.no){ //说明要添加的编号已经存在
                flag = true;
                break;
            }
            temp = temp.next; //后移，遍历当前链表
        }
        if (flag){  //为true说明已经存在
            System.out.printf("%d已经存在",heroNode.no);
        }else {
            //加入到temp后面
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }
    //修改节点的信息，根据no编号来修改
    public void update(HeroNode newHeroNode){
        //判断是否空
        if (head.next==null){
            System.out.println("链表为空");
            return;
        }
        //找到需要修改的节点，根据no
        //定义一个属性变量
        HeroNode temp = head.next;
        boolean flag = false;  //表示是否找到该节点
        while (true){
            if (temp == null){
                break; //说明已经遍历完链表
            }
            if (temp.no == newHeroNode.no){
                //找到了
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //根据flag判断是否找到要修改的节点
        if (flag){
            temp.name = newHeroNode.name;
            temp.nickName = newHeroNode.nickName;
        }else {
            System.out.printf("没有找到编号%d的节点",newHeroNode.no);
        }
    }
    //删除
    //head 不能动，需要一个temp找到删除节点的前一个节点
    //我们在比较时，是temp.next.no 和 需要删除的节点no的比较
    public void delete(int delNo){
        if (head.next==null){
            System.out.println("链表为空，没有东西删");
            return;
        }
        //找到需要删除的节点，根据no
        //定义一个属性变量
        HeroNode temp = head;
        boolean flag = false;  //表示是否找到该节点
        while (true){
            if (temp.next==null){//说明到链表最后
                break;
            }
            if (temp.next.no == delNo){
                //找到了
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag){ //为true表示找到了
            temp.next = temp.next.next;
            list();
        }else {
            System.out.printf("%d该节点不存在",delNo);
        }
    }
    //显示（遍历）
    public void list(){
        //先判断链表是否为空
        if (head.next==null){
            System.out.println("链表为空");
            return;
        }
        //因为head节点不能动，所以需要一个辅助变量temp
        HeroNode temp = head.next;
        while (true){
            //判断是否到最后
            if (temp==null){
                break;
            }
            //输出节点的信息
            System.out.println(temp);
            //将temp后移
            temp = temp.next;
        }
    }
}
class HeroNode{
    public int no;
    public String name;
    public String nickName;
    public HeroNode next;

    public HeroNode() {
    }

    public HeroNode(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}
```

#### **单链表面试题**

1. 求单链表中有效节点的个数

   ```java
   public static int getLength(HeroNode head){
           if (head.next==null){
               System.out.println("链表为空");
               return 0;
           }
           int length = 0;
           HeroNode cur = head.next;
           while (cur!=null){
               length++;
               cur = cur.next;//遍历
           }
           return length;
       }
   ```

   

2. 查找单链表中的倒数第k个节点

   ```java
    //思路：
       //1.写一个方法接收head节点，同时接受一个index
       //2.index表示是倒数第index个节点
       //3.先把链表从头到尾遍历一遍，得到链表的总长度getLength
       //4.得到size后，从链表的第一个开始遍历(size-index)个，就可以得到
       //5.找到了返回该节点，否则返回null
       public static HeroNode findLastIndexNode(HeroNode head,int index){
           if (head.next==null){
               System.out.println("链表为空");
               return null;
           }
           //第一次遍历得到链表的长度
           int size = getLength(head);
           //第二次遍历 size-index位置，就是我们倒数的第k个节点
           //先做一个index的校验
           if (index<0||index>size){
               System.out.println("没有找到");
               return null;
           }
           //定义辅助变量，for循环定位到倒数的index
           HeroNode cur = head.next;
           for (int i = 0; i < size - index; i++) {
               cur = cur.next;
           }
           return cur;
       }
   ```

   

3. 单链表的反转

   思路分析图解：

   <img src="C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210924142925000.png" alt="image-20210924142925000" style="zoom:67%;" />

   思路：先定义一个节点reverseHead = new HeroNode();

   ​			从头到尾遍历原链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端

   ​			原来的链表的head.next = reverseHead.next

   

   ```java
   //将单链表反转
       public static void reverseList(HeroNode head){
           if (head.next == null||head.next.next==null){
               return;
           }
           //定义一个辅助的指针，帮助我们遍历原来的链表
           HeroNode cur = head.next;
           HeroNode next = null;  //指向当前节点【cur】的下一个节点
           HeroNode reverseHead = new HeroNode(0,"","");
           //遍历原来的链表，没遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端
           //动脑筋
           while (cur != null){
               next = cur.next; //先暂时保存当前节点的下一个节点，因为后面需要使用
               cur.next = reverseHead.next; //将cur的下一个节点指向新的链表的最前端
               reverseHead.next = cur; //将cur连接到新的链表上
               cur = next; //后移
           }
           //将head.next指向reverseHead.next  实现单链表的反转
           head.next = reverseHead.next;
       }
   ```

   

4. 从尾到头打印单链表

   ```Java
   //利用栈结构，将各个节点压入到栈中，然后利用栈的特点，就实现了逆序打印的效果
       public static void reversePrint(HeroNode head){
           if (head.next == null){
               return; //空链表，不能打印
           }
           // 创建要个一个栈，将各个节点压入栈
           Stack<HeroNode> stack = new Stack<>();
           HeroNode cur = head.next;
           //将链表的所有节点压入栈
           while (cur != null){
               stack.push(cur);
               cur = cur.next;  //cur后移
           }
           //将栈中的节点进行打印，pop出战
           while (stack.size()>0){
               System.out.println(stack.pop()); //先进后出
           }
       }
   ```

   

5. 合并两个有序的单链表，合并之后的链表依然有序

#### 双向链表应用实例

使用带head头的双向链表实现 排行

管理单项链表的缺点分析

1. 单向链表查找只能一个方向，双向链表可以向前或者向后查找
2. 单向链表不能自我删除，需要靠辅助节点，而双向链表可以自我删除。所以前面单项链表删除节点时，总是找到temp，temp时待删除结点的前一个节点(认真体会)

![image-20210924154212099](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210924154212099.png)

**对上图的说明**

分析双向链表的遍历，修改，删除的操作思路==》代码实现

1. **遍历**和单向链表一样，只是可以向前，也可以向后查找
2. **添加**（默认添加到双向链表的最后）
   1. 先找到双向链表的最后一个节点
   2. temp.next = newHeroNode
   3. newHeroNode.pre = temp；
3. **修改**思路和原理和单项链表一样
4. **删除**
   1. 因为是双向链表，因此，我们可以实现自我删除某个节点
   2. 直接找到要删除这个节点，比如temp
   3. temp.pre.next = temp.next;
   4. temp.next.pre = temp.pre;

```java
public class DoubleLinkedListDemo {
    public static void main(String[] args) {
        HeroNode2 heroNode1 = new HeroNode2(1,"宋江","及时雨");
        HeroNode2 heroNode2 = new HeroNode2(2,"卢俊义","玉麒麟");
        HeroNode2 heroNode3 = new HeroNode2(3,"吴用","智多星 ");
        HeroNode2 heroNode4 = new HeroNode2(4,"林冲","豹子头");

        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        doubleLinkedList.add(heroNode1);
        doubleLinkedList.add(heroNode2);
        doubleLinkedList.add(heroNode3);
        doubleLinkedList.add(heroNode4);

        doubleLinkedList.list();
        doubleLinkedList.update(new HeroNode2(4,"李逵","黑旋风"));

        doubleLinkedList.delete(3);
    }
}

//创建一个双向链表的类
class DoubleLinkedList{
    //先初始化一个头节点，头节点不要动，不放具体的数据
    private HeroNode2 head = new HeroNode2(0,"","");
    //返回头节点
    public HeroNode2 getHead() {
        return head;
    }
    //从双向链表删除一个节点
    //对于双向链表，我们可以直接找到要删除的这个节点
    //找到后自我删除即可
    public void delete(int delNo){
        if (head.next==null){
            System.out.println("链表为空，没有东西删");
            return;
        }
        //找到需要删除的节点，根据no
        //定义一个辅助变量
        HeroNode2 temp = head.next;
        boolean flag = false;  //表示是否找到该节点
        while (true){
            if (temp==null){//说明到链表最后
                break;
            }
            if (temp.no == delNo){
                //找到了
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag){ //为true表示找到了
            temp.pre.next = temp.next;
            //如果是最后一个节点，就不需要执行下面这句话，否则会出现空指针异常
            if(temp.next!=null) {
                temp.next.pre = temp.pre;
            }
            list();
        }else {
            System.out.printf("%d该节点不存在",delNo);
        }
    }
    //修改
    public void update(HeroNode2 newHeroNode){
        if (head.next == null){
            System.out.println("链表为空");
            return;
        }
        //根据no找到要修改的节点
        HeroNode2 temp = head.next;
        boolean flag = false;
        while (true){
            if (temp == null){
                break;
            }
            if (temp.no == newHeroNode.no){
                //找到了
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //根据flag判断是否找到要修改的节点
        if (flag){
            temp.name = newHeroNode.name;
            temp.nickName = newHeroNode.nickName;
        }else {
            System.out.printf("没有找到%d节点",newHeroNode.no);
        }
    }

    //添加一个节点到双向链表最后
    public void add(HeroNode2 heroNode2){
        HeroNode2 temp = head;
        //遍历链表
        while (true){
            if (temp.next == null){
                //找到了
                break;
            }
            //没找到  后移
            temp = temp.next;
        }
        //当执行到这里 说明temp已经到最后一个了
        // 形成一个双向链表
        temp.next = heroNode2;
        heroNode2.pre = temp;
    }
    //显示链表（遍历）
    public void list(){
        if (head.next==null){
            System.out.println("链表为空");
            return;
        }
        HeroNode2 temp = head.next;
        while (true){
            if (temp == null){
                break;
            }
            System.out.println(temp);
            temp = temp.next;
        }
    }
}

class HeroNode2{
    public int no;
    public String name;
    public String nickName;
    public HeroNode2 next; //指向下一个节点默认null
    public HeroNode2 pre;  //指向上一个节点默认null

    public HeroNode2() {
    }

    public HeroNode2(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}
```

双向链表的第二种添加方式

```Java
//第二种添加英雄的方式 ，根据排名插入指定位置
    //（如果有这个排名，则添加失败，给出提示）
    public void addByOrder(HeroNode2 heroNode){
        //因为头节点不能动，因此需要一个辅助指针来帮助找到添加的位置
        HeroNode2 temp = head;
        boolean flag = false;  //用来判断添加的节点是否存在，默认false
        while (true){
            if (temp.next==null){  //说明temp已经在链表的最后了
                break;
            }
            if (temp.next.no > heroNode.no){ //位置找到
                break;
            }
            if (temp.next.no == heroNode.no){ //说明要添加的编号已经存在
                flag = true;
                break;
            }
            temp = temp.next; //后移，遍历当前链表
        }
        if (flag){  //为true说明已经存在
            System.out.printf("%d已经存在",heroNode.no);
        }else {
            //加入到temp后面
            heroNode.next = temp.next;
            if (temp.pre!=null&&temp.next!=null) {
                temp.next.pre = heroNode;
            }
            temp.next = heroNode;
            heroNode.pre = temp;
        }
    }
```

#### 单向环形链表应用场景

约瑟夫问题

![image-20210925175029758](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210925175029758.png)

约瑟夫问题示意图

![image-20210925175156515](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210925175156515.png)

**构建**一个单向的环形链表思路

1.先创建第一个节点，让first指向该节点，并形成环

2.后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可

**遍历**环形链表

1.先让一个辅助指针（变量）curBoy，指向first节点

2.然后通过一个while循环遍历该环形链表即可curBoy.next = =first结束

![image-20210926194918408](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210926194918408.png)

约瑟夫问题-小孩出圈的思路分析图

![image-20210926195035959](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210926195035959.png)

根据用户的输入，生成一个小孩出圈的顺序

n = 5，即有5个人

k = 1，从第一个人开始报数

m = 2，数两下

1. 需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这个节点。 

   补充：小孩报数前，先让first和helper移动k-1次

2. 当小孩报数时，让first和helper指针同时移动m - 1次

3. 这时就可以将first指向的小孩节点出圈

   ​	first = first.next

   ​	helper.next = first

   原来first指向的节点就没有任何引用，就会被回收

代码实现

```java
public class Josepfu {
    public static void main(String[] args) {
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(5);
        circleSingleLinkedList.showBoy();
        circleSingleLinkedList.countBoy(1,2,5);
    }
}
class CircleSingleLinkedList{
    //创建一个first节点，当前没有编号
    private Boy first = null;
    //添加小孩节点，构成一个环形的链表
    public void addBoy(int nums){
        //nums 做一个数据校验
        if (nums < 1){
            System.out.println("nums的值不正确");
            return;
        }
        Boy curBoy = null; //辅助指针，帮助构建环形链表
        //使用for循环创建环形链表
        for (int i = 1; i <= nums; i++) {
            //根据编号，创建小孩节点
            Boy boy = new Boy(i);
            //单独考虑第一个节点  如果是第一个小孩
            if (i ==  1){
                first = boy;
                first.setNext(first); //构成环
                curBoy = first; //让curBoy指向第一个小孩 即curBoy就是first节点
            }else {
                curBoy.setNext(boy); //先指向新的节点
                boy.setNext(first);
                curBoy = boy;  //指针后移
            }
        }
    }

    //遍历当前的环形链表
    public void showBoy(){
        //判断链表是否为空
        if (first == null){
            System.out.println("没有任何boy");
            return;
        }
        //因为first不能动，因此我们仍然使用一个辅助指针完成遍历
        Boy curBoy = first;
        while (true){
            System.out.printf("小孩的编号%d \n",curBoy.getNo());
            if (curBoy.getNext() == first){ //遍历完毕
                break;
            }
            curBoy = curBoy.getNext(); //curBoy后移
        }
    }

    //根据用户的输入，计算出小孩出圈的顺序

    /**
     * startNo表示从第几个小孩开始数数
     * countNum 表示数几下
     *  nums 表示最初有多少小孩再圈中
     */
    public void countBoy(int startNO,int countNum,int nums){
        //先对数据进行校验
        if (first == null ||startNO < 1 || startNO > nums){
            System.out.println("参数输入有误");
            return;
        }
        //创建一个辅助指针，帮助完成小孩出圈
        Boy helper = first;
        // 需求创建一个辅助指针（变量）helper， 事先应该指向环形链表的最后这个节点
        while (true){
            if (helper.getNext()==first){ //说明helper指向最后小孩节点
                break;
            }
            helper = helper.getNext();
        }
        //小孩报数前，先让first和helper移动 k - 1次
        for (int i = 0; i <startNO - 1; i++) {
            first = first.getNext();
            helper = helper.getNext();
        }
        //当小孩报错时，让first和helper指针同时的移动m-1次，然后出圈
        //这里是一个循环操作，直到圈中只有一个节点
        while (true){
            if (helper == first){//说明圈中只有一个节点
                break;
            }
            //让first 和 helper 指针同时的 移动countNum - 1
            for (int i = 0; i < countNum - 1; i++) {
                first = first.getNext();
                helper = helper.getNext();
            }
            //这是first指向的节点，就是要出圈的小孩节点
            System.out.printf("小孩%d出圈\n",first.getNo());
            //这是将first指向的小孩节点出圈
            first = first.getNext();
            helper.setNext(first); //

        }
        System.out.printf("最后留在圈中的小孩编号%d\n",first.getNo());
    }
}
//创建一个boy类，表示一个节点
class Boy{
    private int no; //编号
    private Boy next;  //指向下一个节点，默认null

    public Boy() {
    }

    public Boy(int no) {
        this.no = no;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNext(Boy next) {
        this.next = next;
    }
}
```

### 栈

#### 栈的一个实际需求

![image-20210928145114115](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210928145114115.png)

#### 栈的介绍

1. 栈（stack）

2. 栈是一个**先入后出**的有序列表

3. 栈是限制线性表中元素的插入和删除只能在线性表的同一段进行的一种特殊线性表。允许插入和删除的一端，为**变化的一端，称为栈顶（Top）**，另一端为**固定的一端，称为栈底（Bottom）**。

4. 根据栈的定义可知，最先放入栈中元素再栈底，最后放入元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。

5. 图解方式说明出栈（pop）和入栈（push）

   ​	![image-20210928145652996](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210928145652996.png)

#### 栈的应用场景

1. 子程序的通用：在跳往子程序前，会先将下个指令的地址存到堆栈中，指导子程序执行完后再将地址取出，以回到原来的程序中。
2. 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
3. 表达式的转换[中缀表达式转后缀表达式]与求值（实际解决）。
4. 二叉树的遍历。
5. 图形的深度优先(depth~~first)搜索法。

实现栈的思路分析

1. 使用数组来模拟栈
2. 定义一个top来表示栈顶，初始化为-1
3. **入栈**的操作，当有数据加入到栈时，top++；stack[top] = data;
4. **出栈**的操作，int value = stack[top];top--,return value;

代码实现

```java
public class ArrayStackDemo {
    public static void main(String[] args) {
        ArrayStack stack = new ArrayStack(5);
        int key;
        boolean flag = true; //控制是否退出菜单
        Scanner scanner = new Scanner(System.in);
        while (flag){
            System.out.println("1:显示");
            System.out.println("2:退出");
            System.out.println("3:弹栈");
            System.out.println("4:压栈");
            System.out.println("请输入1-4");
            key = scanner.nextInt();
            switch (key){
                case 1:
                    stack.list();
                    break;
                case 2:
                    scanner.close();
                    flag = false;
                    break;
                case 3:
                    try {
                        int value = stack.pop();
                        System.out.println("取出的数据是"+value);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 4:
                    try {
                        System.out.println("输入要添加的数字");
                        stack.push(scanner.nextInt());
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
            }
        }
        System.out.println("程序退出了");
    }
}
class ArrayStack{
    private int maxSize;
    private int[] stack;
    private int top = -1; //栈帧

    //构造器
    public ArrayStack(int maxSize){
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }
    //沾满
    public boolean isFull(){
        return top == maxSize-1;
    }
    //栈空
    public boolean isEmpty(){
        return top == -1;
    }
    //压栈push
    public void push(int value){
        if (isFull()){
            throw new RuntimeException("栈已满");
        }
        top++;
        stack[top] = value;
        System.out.printf("stack[%d]=%d以入栈\n",top,value);
    }
    //出栈pop,将栈顶的数据返回
    public int pop(){
        if (isEmpty()){
            throw new RuntimeException("栈已空");
        }
        int temp = stack[top];
        top--;
        return temp;
    }
    //显示栈的情况[遍历栈]，遍历时从栈顶开始 显示数据
    public void list(){
        if (isEmpty()){
            System.out.println("栈已空");
            return;
        }
        //需要从栈顶开始显示数据
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n",i,stack[i]);
        }
    }
}
```

关于栈的一个小练习 使用链表来模拟栈

#### 栈实现综合计算器（中缀表达式）

使用栈来实现综合计算器

![image-20210929171918258](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210929171918258.png)

思路分析（图解）

![image-20210929171947628](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210929171947628.png)

代码实现1.先实现一位数的运算  2.扩展到多位数的运算

课后的练习-给表达式加入小括号

```Java
public class Calculator {
    public static void main(String[] args) {
        String expression = "30+10*6-2*5*5";
        //创建两个栈，数栈  和  符号栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operStack = new ArrayStack2(10);
        //定义需要的相关变量
        int index = 0; //用于扫描
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int res =  0;
        char ch = ' '; //将每次扫描得到的char保存到ch
        String keepNum = "";//用于拼接 多位数
        //开始while循环  扫描expression
        while (true){
            //依次得到expression 的每一个字符
            ch = expression.substring(index,index+1).charAt(0);
            //判断ch是什么，然后做出相应的处理
            if (operStack.isOper(ch)){ //如果是运算符
                //判断当前符号栈是否为空
                if (!operStack.isEmpty()){
                    //如果符号栈有操作符，就进行比较，如果 当前的操作符的优先级小于或者等于栈中的操作符，
                    //就需要从数栈中pop出两个数，再从符号栈中pop出一个符号，进行运算，将得到的结果入数栈，
                    // 然后将当前的操作符入符号栈
                    if (operStack.priority(ch) <= operStack.priority(operStack.peek())){
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        res = numStack.cal(num1,num2,oper);
                        //把运算的结果入数栈
                        numStack.push(res);
                        //然后将当前的操作符入符号栈
                        operStack.push(ch);
                    }else {
                        //如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈
                        operStack.push(ch);
                    }
                }else {
                    //如果为空直接入栈
                    operStack.push(ch);
                }
            }else { //如果是数
//                numStack.push(ch - 48); // '1' => ASC码
                //如果是多位数 思路分析
                //1.当处理多位数时，不能发现是一个数就入栈
                //2.在处理数时，需要向expression的表达式的index后 再看一位，
                //  如果是数就接着扫描 如果是符号就入栈
                //3.因此我们需要定义个变量 字符串，用于拼接

                //处理多位数
                keepNum +=ch;

                //如果ch已经是expression的最后一位，就直接入栈
                if (index == expression.length()-1){
                    numStack.push(Integer.parseInt(keepNum));
                }else { //不是最后一位
                    //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈
                    //只是看一下index的下一位，不用index++
                    if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))){
                        //如果是运算符 就入栈keepNum = "1"或者"123"
                        numStack.push(Integer.parseInt(keepNum));
                        //注意将keepNum清空！！！！！！
                        keepNum = "";

                    }
                }
            }
            //让index + 1，并判断是否扫描到expression最后
            index++;
            if (index >= expression.length()){
                break; //扫描结束
            }
        }
        //当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行
        while (true){
            //如果符号栈为空，则计算到最后的结果，数栈中只有一个数字【结果】
            if (operStack.isEmpty()){
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            res = numStack.cal(num1,num2,oper);
            numStack.push(res); //入栈
        }
        System.out.printf("表达式%s = %d",expression,numStack.pop());
    }
}
//先创建一个栈，直接使用前面创建好的
class ArrayStack2{
    private int maxSize;
    private int[] stack;
    private int top = -1; //栈帧

    //构造器
    public ArrayStack2(int maxSize){
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }
    //增加一个方法，可以返回当前栈顶的值，但是不是真正的pop
    public int peek(){
        return stack[top];
    }
    //栈满
    public boolean isFull(){
        return top == maxSize-1;
    }
    //栈空
    public boolean isEmpty(){
        return top == -1;
    }
    //压栈push
    public void push(int value){
        if (isFull()){
            throw new RuntimeException("栈已满");
        }
        top++;
        stack[top] = value;
//        System.out.printf("stack[%d]=%d以入栈\n",top,value);
    }
    //出栈pop,将栈顶的数据返回
    public int pop(){
        if (isEmpty()){
            throw new RuntimeException("栈已空");
        }
        int temp = stack[top];
        top--;
        return temp;
    }
    //显示栈的情况[遍历栈]，遍历时从栈顶开始 显示数据
    public void list(){
        if (isEmpty()){
            System.out.println("栈已空");
            return;
        }
        //需要从栈顶开始显示数据
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n",i,stack[i]);
        }
    }
    //返回运算符的优先级，优先级是程序员来确定的，优先级使用数字表示
    //数字越大，则优先级越高
    public int priority(int oper){
        if (oper == '*' || oper == '/'){
            return 1;
        }else if (oper == '+' || oper == '-'){
            return 0;
        }else {
            return  -1; //假定目前的表达式只有 + - * /
        }
    }
    //判断是不是一个运算符
    public boolean isOper(char val){
        return val == '+' || val == '-' || val == '*' || val == '/';
    }
    //计算方法
    public int cal(int num1,int num2,int oper){
        int res = 0; //res 用于存放计算的结果
        switch (oper){
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1;  //注意顺序
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2 / num1;
                break;
        }
        return res;
    }
}
```

### 前缀、中缀、后缀表达式（逆波兰表达式）

#### 前缀表达式（波兰表达式）

1. 前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前
2.  举例（3+4）× 5 - 6 对应的前缀表达式就是 - × + 3 4 5 6

前缀表达式的计算机求值

从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素和次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

例如：（3+4）× 5 - 6 对应的前缀表达式就是 - × + 3 4 5 6，针对前缀表达式求值步骤如下：

1. 从右至左扫描，将6、5、4、3压入堆栈
2. 遇到 + 运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3 + 4的值，得7，再将7入栈
3. 接下来时× 运算符，因此弹出7和5，计算出7 × 5 = 35，将35入栈
4. 最后时 -运算符，计算出35-6的值，即29，由此得出最终结果。 

#### 中缀表达式

1. 中缀表达式就是**常见的运算表达式**，如（3+4）× 5 - 6 
2. 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作（前面的案例可以看出这个问题），因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作（一般转成后缀表达式）

#### 后缀表达式

1. 后缀表达式又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后

2. 例如：（3+4）× 5 - 6  对应的后缀表达式就是 ***3 4 + 5 × 6 -***

3. 再比如：

   ![image-20210930151813060](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20210930151813060.png)

后缀表达式的计算机求值

由左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素和栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

例如：（3+4）× 5 - 6  对应的后缀表达式就是 ***3 4 + 5 × 6 -*** ，针对后缀表达式求值步骤如下：

1. 从左至右，将3和4压入堆栈；
2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
3. 将5入栈；
4. 接下来就是 × 运算符，因此弹出5和7，计算出7×5=35，将35入栈；
5. 将6入栈；
6. 最后是 ➖ 运算符，计算出35 - 6 得值 29，由此得出最终结果

#### 逆波兰计算器

1. 输入一个逆波兰表达式（后缀表达式），使用栈，计算其结果
2. 支持小括号和多位数整数，（简化：只支持**对整数**得计算）
3. 思路分析
4. 代码实现

```Java
public class PolandNotation {
    public static void main(String[] args) {
        //先定义一个逆波兰表达式
        //（3+4）× 5 - 6  对应的后缀表达式就是3 4 + 5 × 6 -
        // 4 * 5 - 8 + 60 + 8 / 2 => 76
        //测试（30+4）× 5 - 6  164
        //为了方便，逆波兰表达式得数字和符号使用空格隔开
//        String suffixExpression = "30 4 + 5 * 6 -";
        String suffixExpression = "4 5 * 8 - 60 + 8 2 / +";
        //思路
        //1.先将"3 4 + 5 * 6 -" => 放到ArrayList中
        //2.将ArrayList 传递 给一个方法，遍历ArrayList 配合栈 完成计算
        List<String> retList = getListString(suffixExpression);
        System.out.println(retList);
        int res = calculate(retList);
        System.out.println(res);
    }
    //将一个逆波兰表达式，依次将数据和运算符 放入到ArrayList中
    public static List<String> getListString(String suffixExpression){
        //将 suffixExpression 按空格分割
        String[] split = suffixExpression.split(" ");
        List<String> list  = new ArrayList<>();
        for (String ele: split){
            list.add(ele);
        }
        return list;
    }

    //完成对逆波兰表达式的运算
    /**
     * 1. 从左至右，将3和4压入堆栈；
     * 2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
     * 3. 将5入栈；
     * 4. 接下来就是 × 运算符，因此弹出5和7，计算出7×5=35，将35入栈；
     * 5. 将6入栈；
     * 6. 最后是 ➖ 运算符，计算出35 - 6 得值 29，由此得出最终结果
     */
    public static int calculate(List<String> list){
        Stack<String> stack = new Stack<>();
        //遍历
        for (String item: list) {
            if (item.matches("\\d+")){ //匹配的是多位数
                //入栈
                stack.push(item);
            }else { //符号
                //pop出两个数，并运算,再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")){
                    res = num1 + num2;
                } else if (item.equals("-")){
                    res = num1 - num2;
                } else if (item.equals("*")){
                    res = num1 * num2;
                } else if (item.equals("/")){
                    res = num1 / num2;
                } else {
                    System.out.println("运算符有误");
                    return -1;
                }
                //把res 入栈
                stack.push(""+res);
            }
        }
        //最后留在stack中的数据是运算结果
        return Integer.parseInt(stack.pop());
    }
}
```

#### 中缀表达式转后缀表达式

后缀表达式适合计算机进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将**中缀表达式**转成**后缀表达式**。

具体思路步骤：

1. 初始化两个栈：运算符栈s1和储存中间结果的栈2；
2. 从左至右扫面中缀表达式
3. 遇到操作数时，将其压s2；
4. 遇到运算符时，比较其与s1栈顶运算符的优先级；
   1. 如果s1为空，或栈顶运算符为左括号“（”，则直接将此运算符入栈；
   2. 否则，若优先级比栈顶运算符的高，也将运算符压入s1；
   3. 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到（4.1）与s1中新的栈顶运算符相比较；
5. 遇到括号时：
   1. 如果是左括号“（”，则直接压入s1
   2. 如果是右括号“）”，则依次弹出s1栈顶的运算符，并压入s2，指导遇到左括号为止，此时将这一堆括号丢弃
6. 重复步骤2至5，直到表达式的最右边
7. 将s1中剩余的运算符依次弹出并压入s2
8. 依次弹出s2中的元素并输出，**结果的逆序即为中序表达式对应的后缀表达式**

中缀表达式1+ ( ( 2 + 3 ) × 4 ) - 5=>后缀表达式

<img src="C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211001135644696.png" alt="image-20211001135644696" style="zoom: 80%;" />

```Java
public class PolandNotation {
    public static void main(String[] args) {

        //将一个中缀表达式转成后缀表达式的功能
        //说明
        //1.  “1 + ((2 + 3) * 4) - 5” -> "1 2 3 + 4 * + 5 -"
        //2.  因为直接去扫描一个字符串  不是很方便，因此 先将“1 + ((2 + 3) * 4) - 5” =>中缀的表达式对应的list
        //      即转为Array[1,+,(,(,2,+,3),*,4,),-,5]
        //3.将得到的中缀表达式对应的List => 后缀表达式对应的List
        //      即 Array[1,+,(,(,2,+,3),*,4,),-,5] => Array[1,2,3,+,4,*,+,5,-]
        String expression = "1+((2+3)*4)-5";
        List<String> list = toInfixExpression(expression);
        System.out.println("中缀表达式对应的List"+list);
        List<String> suffixExpressionList = parseSuffixExpressionList(list);
        System.out.println("后缀表达式对应的LIST"+suffixExpressionList);

        System.out.printf("expression=%d",calculate(suffixExpressionList));
        /*

        //先定义一个逆波兰表达式
        //（3+4）× 5 - 6  对应的后缀表达式就是3 4 + 5 × 6 -
        // 4 * 5 - 8 + 60 + 8 / 2 => 76
        //测试（30+4）× 5 - 6  164
        //为了方便，逆波兰表达式得数字和符号使用空格隔开
//        String suffixExpression = "30 4 + 5 * 6 -";
        String suffixExpression = "4 5 * 8 - 60 + 8 2 / +";
        //思路
        //1.先将"3 4 + 5 * 6 -" => 放到ArrayList中
        //2.将ArrayList 传递 给一个方法，遍历ArrayList 配合栈 完成计算
        List<String> retList = getListString(suffixExpression);
        System.out.println(retList);
        int res = calculate(retList);
        System.out.println(res);

         */
    }

    //方法：将得到的中缀表达式对应的List => 后缀表达式对应的List
    public static List<String> parseSuffixExpressionList(List<String> ls){
        //定义两个栈
        Stack<String> s1 = new Stack<>();  //符号栈
        //说明：因为s2这个栈在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出
        //这样比较麻烦，所以就不用Stack<String> 直接使用List
//        Stack<String> s2 = new Stack<>();  //  储存中间结果的栈s2
        List<String> s2 = new ArrayList<>();  //储存中间结果的s2

        //遍历ls
        for (String item:ls){
            //如果是一个数，加入到s2
            if (item.matches("\\d+")){
                s2.add(item);
            }else if (item.equals("(")){
                s1.push(item);
            }else if (item.equals(")")){
                //如果是右括号“）”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一堆括号丢弃
                while (!s1.peek().equals("(")){
                    s2.add(s1.pop());
                }
                s1.pop();//!!!将 （  弹出s1栈，消除小括号
            }else {
                //当item的优先级小于等于栈顶运算符，将s1栈顶的运算符弹出并加入到s2中，再次转到（4.1）与s1中新的栈顶运算符相比较
                //  缺少一个比较优先级高低的方法
                while (s1.size()!=0 && Operation.getValue(s1.peek())>= Operation.getValue(item)){
                    s2.add(s1.pop());
                }
                //还需要将item压入栈
                s1.push(item);
            }
        }

        //将s1中剩余的运算符依次弹出并加入s2
        while (s1.size()!=0){
            s2.add(s1.pop());
        }

        return s2; //因为是存放到list中，所以按顺序输出就是对应的后缀表达式
    }

    //方法：将中缀表达式转成对应的List
    //  s = "1+((2+3)*4)-5"
    public static List<String> toInfixExpression(String s){
        //定义一个List，存放中缀表达式对应的内容
        List<String> ls = new ArrayList<>();
        int i = 0;  //这是一个指针，用于遍历中缀表达式字符串
        String str; //对多位数的拼接
        char c;     //每遍历到一个字符，就放入到c
        do {
            //如果c是一个非数字，需要加入到ls
            if ( (c=s.charAt(i))<48 || (c=s.charAt(i))>57){
                ls.add(""+c);
                i++; //i后移
            }else { //如果是一个数，需要考虑多位数
                str = "";  //先将str 置成""  '0'[48]->'9'[57]
                while (i < s.length()&&(c=s.charAt(i))>=48&&(c=s.charAt(i))<=57){
                    str += c; //拼接
                    i++;
                }
                ls.add(str);
            }
        }while (i < s.length());
        return ls;
    }

    //将一个逆波兰表达式，依次将数据和运算符 放入到ArrayList中
    public static List<String> getListString(String suffixExpression){
        //将 suffixExpression 按空格分割
        String[] split = suffixExpression.split(" ");
        List<String> list  = new ArrayList<>();
        for (String ele: split){
            list.add(ele);
        }
        return list;
    }

    //完成对逆波兰表达式的运算
    /**
     * 1. 从左至右，将3和4压入堆栈；
     * 2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
     * 3. 将5入栈；
     * 4. 接下来就是 × 运算符，因此弹出5和7，计算出7×5=35，将35入栈；
     * 5. 将6入栈；
     * 6. 最后是 ➖ 运算符，计算出35 - 6 得值 29，由此得出最终结果
     */
    public static int calculate(List<String> list){
        Stack<String> stack = new Stack<>();
        //遍历
        for (String item: list) {
            if (item.matches("\\d+")){ //匹配的是多位数
                //入栈
                stack.push(item);
            }else { //符号
                //pop出两个数，并运算,再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")){
                    res = num1 + num2;
                } else if (item.equals("-")){
                    res = num1 - num2;
                } else if (item.equals("*")){
                    res = num1 * num2;
                } else if (item.equals("/")){
                    res = num1 / num2;
                } else {
                    System.out.println("运算符有误");
                    return -1;
                }
                //把res 入栈
                stack.push(""+res);
            }
        }
        //最后留在stack中的数据是运算结果
        return Integer.parseInt(stack.pop());
    }
}

//编写一个类 Operation  可以返回一个运算符 对应的优先级
class Operation{
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;

    //写一个方法，返回对应的优先级数字
    public static int getValue(String operation){
        int result = 0;
        switch (operation){
            case "+":
                result = ADD;
                break;
            case "-":
                result = SUB;
                break;
            case "*":
                result = MUL;
                break;
            case "/":
                result = DIV;
                break;
            default:
                System.out.println("符号有误");
                break;
        }
        return result;
    }
}
```

逆波兰计算器完整版

功能包括

1. 支持+ - * /（）
2. 多位数，支持小数
3. 兼容处理，过滤任何空白字符，包括空格、制表符、换页符

### 递归

#### 1 递归的应用场景

迷宫问题（回溯），递归（Recursion）

#### 2 递归的概念

递归就是方法自己调用自己，每次调用时传入不同的变量.**递归有助于编程者解决复杂的问题**，同时可以让代码变得简洁。

#### 3 递归的调用机制

打印问题

阶乘问题

![image-20211005111756632](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211005111756632.png)

#### 4 递归能解决什么样的问题

各种数学问题如：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题

各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法

将用栈解决的问题-->递归代码比较简洁

#### 5 递归需要遵守的重要规则

1. 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
2. 方法的局部变量是独立的，不会相互影响，比如n变量
3. 如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据
4. 递归**必须向退出递归的条件逼近**，否则就是无限递归了，出现StackOverflowError
5. 当一个方法执行完毕，或者遇到return，就会返回，**遵守谁调用，就将结果返回给谁**，同时当方法执行完毕或者返回时，该方法也就执行完毕

#### 6 迷宫问题

代码实现

```java
public class MiGong {
    public static void main(String[] args) {
        int[][] miGong = new int[8][7];

        for (int i = 0; i < miGong.length; i++) {
            miGong[i][0] = 1;
            miGong[i][miGong[i].length-1] = 1;
        }

        for (int i = 0; i < miGong.length; i++) {
            for (int j = 0; j < miGong[i].length; j++) {
                miGong[0][j] = 1;
                miGong[miGong.length-1][j] = 1;
            }
        }

        miGong[3][1] = 1;
        miGong[3][2] = 1;
        miGong[2][2] = 1;

        for (int i = 0; i < miGong.length; i++) {
            for (int j = 0; j < miGong[i].length; j++) {
                System.out.print(miGong[i][j]+"\t");
            }
            System.out.println();
        }

        setWay(miGong,1,1);
        for (int i = 0; i < miGong.length; i++) {
            for (int j = 0; j < miGong[i].length; j++) {
                System.out.print(miGong[i][j]+"\t");
            }
            System.out.println();
        }
    }
    //使用递归回溯来给小球找路

    /**
     *
     * @param map 地图
     * @param i j 从哪开始找
     * @return 如果找到通路，返回true
     */

    // 当map[][] = 0的时候表示还没有走过，为1表示墙；2表示通路可以走；3表示该店已经走过，但是走不通
    // 确定一个策略 下 右 上 左，如果该点走不通，再回溯
    public static boolean setWay(int[][] map, int i,int j){
        if (map[6][5]==2){  //通路
            return true;
        }else {
            if (map[i][j]==0){ //如果当前这个点还没有走过
                //按照策略 ↓ ← ↑ →
                map[i][j] = 2; //假定该点是可以走通
                if (setWay(map,i+1,j)){ //向下走
                    return true;
                }else if (setWay(map, i, j+1)){
                    return true;
                }else if (setWay(map, i-1, j)){
                    return true;
                }else if (setWay(map, i, j-1)){
                    return true;
                }else {
                    //说明该点是走不通
                    map[i][j] = 3;
                    return false;
                }
            }else { //如果！= 0，可能是 1 2 3
                return false;
            }
        }
    }
}
```

#### 7 递归-八皇后问题（回溯算法）

八皇后问题算法思路分析

1. 第一个皇后先放第一行第一列
2. 第二个皇后放在第二行第一列、然后判断是否OK，如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适的
3. 继续第三个皇后，还是第一列、第二列......直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解
4. 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解全部得到
5. 然后回头继续第一个皇后放第二列，后面继续循环执行1，2，3，4的步骤

**说明：**理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题。arr[8] = {0,4,7,5,2,6,1,3}

对应arr下标表示 第几行，即第几个皇后，arr[i] = val , val 表示第i + 1个皇后，放在第i + 1行的第val + 1列

代码实现

```Java
public class Queen8 {

    //定义一个max表示共有多少个皇后
    int max = 8;
    //定义数组array，保存皇后放置位置的结果，比如arr = {0,4,7,5,2,6,1,3}
    int[] array = new int[max];
    static int count = 0;
    public static void main(String[] args) {
        Queen8 queen8 = new Queen8();
        queen8.check(0);
        System.out.println(count);
    }

    //编写一个方法，放置第n个皇后
    //特别注意：check 是每一次递归时，进入到check中 都有for (int i = 0; i < max; i++),因此会有回溯
    private void check(int n){
        if (n == max){ //n = 8,其实8个皇后已经放好了
            print();
            return;
        }

        //依次放入皇后，并判断是否冲突
        for (int i = 0; i < max; i++) {
            //先把当前这个皇后n，放到改行的第一列
            array[n] = i;
            //判断当放置第n个皇后到i列时，是否冲突
            if (judge(n)){
                // 接着放n+1个皇后，即开始递归
                check(n+1);
            }

            //如果冲突 ，就继续执行 array[n] = i;即将第n个皇后，放置在本行的后移的一个位置
        }
    }

    //查看当我们放置第n个皇后，就去检测该皇后是否和前面已经摆放的皇后冲突

    private boolean judge(int n){
        for (int i = 0;i < n;i++){
            // 如果摆放的第n个皇后跟之前摆放的n-1个在同一列或者在同一对角线 不能摆放
            // Math.abs  绝对值
            if (array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n]-array[i])){
                return false;
            }
        }
        return true;
    }
    //输出皇后摆放的位置
    private void print(){
        count++;
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
}
```

### 排序算法

#### 排序算法的介绍

排序也称排序算法，排序是将**一组数据**，依**指定的顺序**进行**排列的过程。**

排序的分类：

1. 内部排序：指将需要处理的所有数据都加载到**内部存储器（内存）**中进行排序
2. 外部排序法：**数据量过大**，无法全部加载到内存中，需要借助**外部存储（文件等）**进行排序
3. 常见的排序算法分类：

![image-20211006140958316](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211006140958316.png)

### 算法的时间复杂度

度量一个程序（算法）执行时间的两种方式

1. 事后统计的方法：这种方法可行，但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，**这种方式，要在同一台计算机的相同状态下运行，才能比较哪个算法速度更快。**
2. 事前估算的方法：通过分析某个算法的**时间复杂度**来判断啊哪个算法更优。

#### 时间频度

时间频度：一个算法花费的时间与算法中语句的执行次数成正比，哪个算法中语句执行次数多，它花费时间就多。**一个算法中的语句执行次数称为语句频度或时间频度**。记作T(n)。

举例说明-基本案例

比如计算1-100所有数字之和，我们设计两种算法：

<img src="C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211006160312167.png" alt="image-20211006160312167" style="zoom: 67%;" />

举例说明-**忽略常数项**

![image-20211006160450231](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211006160450231.png)

结论：

1. 2n+20 和 2n 随着 n 变大，执行曲线无限接近，20可以忽略
2. 3n+10 和 3n 随着 n 变大，执行曲线无限接近，10可以忽略

举例说明-**忽略低次项**

![image-20211006160702695](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211006160702695.png)

结论：

1. 2n^2+3n+10 和 2n^2随着n 变大，执行曲线无限接近，可以忽略 3n+10
2. n^2 + 5n + 20 和 n^2随着n变大，执行曲线无限接近，可以忽略 5n+20

举例说明-**忽略系数**

![image-20211006160927567](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211006160927567.png)

结论：

1. 随着n值变大，5n^2+7n 和 3n^2+2n，执行曲线重合，说明这种情况下，5和 3可以忽略
2. 而n^3+5n 和 6n^3+4n，执行曲线分离，说明多少次方是关键

#### 时间复杂度

1. 一般情况下，**算法中的基本操作语句的重复执行次数是问题规模n的某个函数**，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作**T(n)=O(f(n))**，称O(f(n))为算法的渐近时间复杂度，简称时间复杂度。
2. T(n)不同，但时间复杂度可能相同。如：T(n)=n^2+7n+6 与 T(n)=3n^2+2n+2它们的T(n)不同，但时间复杂度相同，都为O(n^2)。
3. 计算时间复杂度的方法：
   - 用常数1代替运行时间中的所有加法常数T(n)=n^2+7n+6 => T(n)=n^2+7n+1
   - 修改后的运行次数函数中，只保留最高阶项T(n)=n^2+7n+1 => T(n) = n^2
   - 去除最高阶项的系数T(n) = n^2 => T(n) = n^2 => O(n^2)

#### 常见的时间复杂度

1. 常数阶O(1)
2. 对数阶O(log2n)
3. 线性阶O(n)
4. 线性对数阶O(nlog2n)
5. 平方阶O(n^2)
6. 立方阶O(n^3)
7. k次方阶O(n^k)
8. 指数阶O(2^n)

常见的时间复杂度对应的图

<img src="C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211006174254631.png" alt="image-20211006174254631" style="zoom:67%;" />

说明：

1. 常见的算法时间复杂度由小到大依次为：O(1)<O(log2n)<O(n)<O(nlog2n)<O(n^2)<O(n^3)<k次方阶O(n^k)<指数阶O(2^n)，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低
2. 从图中可见，我们应该尽可能 避免使用指数阶的算法

常见的时间复杂度

常数阶O(1)

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度都是O(1)

![image-20211006174421574](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211006174421574.png)

上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

对数阶O(log2n)

```Java
int i = 1
    while(i<n){
        i = i * 2;
    }
```

说明：在while循环里面，每次都将i乘以2，乘完之后，i距离n就越来越近了。假设循环x次之后，i就大于2了，此时这个循环就退出了，也就是说2的x次方等于n，那么 x = log2n

也就是说当循环 x = log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)。O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3，则是O(log3n).

​		如果N  = a^x(a>0，a != 1)，即a的x次方等于N(a>0，a != 1)，那么数x叫做以a为底N的对数，记作 x = logaN。其中，a叫做对数的底数，N叫做真数，x叫做“以a为底N的对数”

线性阶O(n)

![image-20211006175410111](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211006175410111.png)

线性对数阶 O(nlog2n)

![image-20211006175456325](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211006175456325.png)

**平方阶O(n^2)**

![image-20211006175555411](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211006175555411.png)

立方阶O(n^3)   k次方阶k次方阶O(n^k)

参照上面的O（n^2）去理解就好了，O(n^3)相当于三层n循环，其它的类似

#### 平均时间复杂度和最坏时间复杂度

1. 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
2. 最坏情况下的时间复杂度称最坏时间复杂度。**一般讨论的时间复杂度均是最坏情况下的时间复杂度**。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长
3. 平均时间复杂度和最坏时间复杂度是否一致，和算法有关（如图：）

![image-20211006180217637](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211006180217637.png)

### 算法的空间复杂度简介

基本介绍

1. 类似于时间复杂度的讨论，一个算法的空间复杂度定义为 该算法所耗费的存储空间，它也是问题规模n的函数
2. 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况
3. 在做算法分析时，主要讨论的是时间复杂度。**从用户体验上看，更看重的是程序的执行速度**。一些缓存产品（redis，memcache）和算法（基数排序）**本质就是用空间换时间**。

#### 冒泡排序

冒泡排序的基本思想是：通过对待排序序列从前往后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。

因为排序的过程中，各元素不断接近自己的位置，**如果一趟比较下来没有进行过交换，就说明序列有列**，因此要在排序过程中设置一个 标志flag判断元素是否进行郭交换。从而减少不必要的比较。（这里说的优化，可以在冒泡排序写好后，再进行）

冒泡排序规则：

1. 一共进行数组的大小 -1次大的循环
2. 每一趟排序的次数在逐渐的减少
3. 如果我们发现在某次排序中，没有发生一次交换，可以提前结束冒泡排序。这个就是优化。

代码实现

```java
public class BubbleSort {
    public static void main(String[] args) {
//        int[] arr = {3,9,-1,10,-2};
//        int[] arr = {3,9,-1,10,20};

        int[] arr = new int[80000];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random() * 8000000);
        }

        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH-mm-ss");
        String format = simpleDateFormat.format(date1);
        System.out.println("排序前的时间是=" + format);

        bubbleSort(arr);

        Date date2 = new Date();
        String format1 = simpleDateFormat.format(date2);
        System.out.println("排序后的时间是=" + format1);

        //演变过程

        /*
        //第二趟排序，将最二大的数排在倒数第二位
        for (int i = 0; i < arr.length - 1 - 1; i++) {
            if (arr[i]>arr[i+1]){
                temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
            }
        }

        System.out.println("第二趟排序后的数组");
        System.out.println(Arrays.toString(arr));
        //第三趟排序，将最三大的数排在倒数第三位
        for (int i = 0; i < arr.length - 1 - 2; i++) {
            if (arr[i]>arr[i+1]){
                temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
            }
        }

        System.out.println("第三趟排序后的数组");
        System.out.println(Arrays.toString(arr));
        //第四趟排序，将最四大的数排在倒数第四位
        for (int i = 0; i < arr.length - 1 - 3; i++) {
            if (arr[i]>arr[i+1]){
                temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
            }
        }

        System.out.println("第四趟排序后的数组");
        System.out.println(Arrays.toString(arr));*/
    }
    public static void bubbleSort(int[] arr){
        //冒泡排序的时间复杂度 O^2
        int temp = 0; //临时变量
        boolean flag = false; //标识变量，表示是否进行过交换
        for (int h = 0; h < arr.length - 1; h++) {
            for (int i = 0; i < arr.length - 1 - h; i++) {
                if (arr[i]>arr[i+1]){
                    flag = true;
                    temp = arr[i];
                    arr[i] = arr[i+1];
                    arr[i+1] = temp;
                }
            }
//            System.out.println("第"+(h+1)+"趟排序后的数组");
//            System.out.println(Arrays.toString(arr));

            if (flag == false){ //说明在一次排序过程中，没有发生交换
                break;
            }else {
                flag = false; //重置flag，进行下次判断
            }
        }
    }
}

```

#### 选择排序

选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。

**选择排序思想**

选择排序也是一种简单的排序方法。它的基本思想是：

​		第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，……，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，……第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按顺序码从小到大的排列的有序序列。

![image-20211006205912524](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211006205912524.png)

代码实现

```Java
public class SelectSort {
    public static void main(String[] args) {
//        int[] arr = {101,34,119,1};
        int[] arr = new int[80000];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random()*8000000);
        }
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH-mm-ss");
        String format = simpleDateFormat.format(date1);
        System.out.println("排序前"+format);

        selectSort(arr);
        Date date2 = new Date();
        String format1 = simpleDateFormat.format(date2);
        System.out.println("排序后"+format1);

//        System.out.println("排序后");
//        System.out.println(Arrays.toString(arr));
    }
    //选择排序
    public static void selectSort(int[] arr){
        //推导过程
        //第一轮
        //原始的数组 ： 101，34，119，1
        //第一轮排序 ： 1，34，119，101
        //算法 先简单--》 做复杂

        //选择排序的时间复杂度O(n^2)
        for (int i = 0; i < arr.length-1; i++) {
            int minIndex = i;
            int min = arr[i]; //假定第一个数是最小的
            for (int j = i + 1; j < arr.length; j++) {
                if (min > arr[j]){ //如果不是最小值，就记录一下位置
                    min = arr[j];
                    minIndex = j;
                }
            }
            //执行到这里，说明已经找到最小值和它的位置了，将其交换至第一个位置
            if (minIndex != i) { //说明发生交换了 说明需要进行如下的操作
                arr[minIndex] = arr[i];
                arr[i] = min;
            }

//            System.out.println("第一轮后~~");
//            System.out.println(Arrays.toString(arr)); //1,34,119,101
        }


        /*
        //第2轮
        minIndex = 1;
        min = arr[1]; //从第二个开始
        for (int j = 1+1; j < arr.length; j++) {
            if (min>arr[j]){ //如果不是最小值，就记录一下位置
                min = arr[j];
                minIndex = j;
            }
        }
        //执行到这里，说明已经找到最小值和它的位置了，将其交换至第二个位置
        arr[minIndex] = arr[1];
        arr[1] = min;

        System.out.println("第二轮后~~");
        System.out.println(Arrays.toString(arr)); //1,34,119,101
        //第3轮
        minIndex = 2;
        min = arr[2]; //从第三个开始
        for (int j = 1+2; j < arr.length; j++) {
            if (min>arr[j]){ //如果不是最小值，就记录一下位置
                min = arr[j];
                minIndex = j;
            }
        }
        //执行到这里，说明已经找到最小值和它的位置了，将其交换至第三个位置
        arr[minIndex] = arr[2];
        arr[2] = min;

        System.out.println("第三轮后~~");
        System.out.println(Arrays.toString(arr)); //1,34,101,119

         */
    }
}
```

#### 插入排序

插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。

插入排序法思想：

插入排序的**基本思想是**：把n个待排序的元素看成为一个有序表和一个无序表，**开始时有序表中只包含一个元素，无序表中包含有n-1个元素**，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

代码实现

```Java
public class InsertSort {
    public static void main(String[] args) {
//        int[] arr = {101,34,119,1};
        int[] arr = new int[80000];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random()*8000000);
        }
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH-mm-ss");
        String format = simpleDateFormat.format(date1);
        System.out.println(format);

        insertSort(arr);

        Date date2 = new Date();
        String format1 = simpleDateFormat.format(date2);
        System.out.println(format1);

    }
    public static void insertSort(int[] arr){
        //推导过程
        //第一轮{101，34，119，1}；=>{34，101，119，1}
		
        int insertVal = 0;
        int insertIndex = 0;
        for (int i = 1; i < arr.length; i++) {

            //定义待插入的数
            insertVal = arr[i];
            insertIndex = i - 1; //arr[i]前一个的数的下标

            //给insertVal  找到插入的位置
            //说明
            //1.insertIndex >= 0 保证在给insertVal 找插入位置，不越界
            //2.insertVal < arr[insertIndex] 待插入的数，还没有找到插入的位置
            //3.就需要将arr[insertIndex] 后移
            while (insertIndex >= 0 && insertVal < arr[insertIndex]) {
                arr[insertIndex + 1] = arr[insertIndex];
                insertIndex--;
            }
            //当退出while循环时，说明插入的位置找到，insertIndex + 1

            //这里判断是否需要赋值
            if (insertIndex + 1 != i) {
                arr[insertIndex + 1] = insertVal;
            }
//            System.out.println("第"+i+"轮");
//            System.out.println(Arrays.toString(arr));
        }
/*
        //第二轮
        //定义待插入的数
        insertVal = arr[2];
        insertIndex = 2 - 1; //arr[2]前一个的数的下标

        //给insertVal  找到插入的位置
        //说明
        //1.insertIndex >= 0 保证在给insertVal 找插入位置，不越界
        //2.insertVal < arr[insertIndex] 待插入的数，还没有找到插入的位置
        //3.就需要将arr[insertIndex] 后移
        while (insertIndex >= 0 && insertVal < arr[insertIndex]){
            arr[insertIndex + 1] = arr[insertIndex];
            insertIndex--;
        }
        //当退出while循环时，说明插入的位置找到，insertIndex + 1
        arr[insertIndex + 1] = insertVal;

        System.out.println("第二轮");
        System.out.println(Arrays.toString(arr));

        //第三轮
        //定义待插入的数
        insertVal = arr[3];
        insertIndex = 3 - 1; //arr[3]前一个的数的下标

        //给insertVal  找到插入的位置
        //说明
        //1.insertIndex >= 0 保证在给insertVal 找插入位置，不越界
        //2.insertVal < arr[insertIndex] 待插入的数，还没有找到插入的位置
        //3.就需要将arr[insertIndex] 后移
        while (insertIndex >= 0 && insertVal < arr[insertIndex]){
            arr[insertIndex + 1] = arr[insertIndex];
            insertIndex--;
        }
        //当退出while循环时，说明插入的位置找到，insertIndex + 1
        arr[insertIndex + 1] = insertVal;

        System.out.println("第三轮");
        System.out.println(Arrays.toString(arr));

 */
    }
}
```

#### 希尔排序

![image-20211007155945558](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211007155945558.png)

希尔排序法介绍

希尔排序是希尔于1959年提出的一种排序算法。希尔排序也是一种**插入排序**，它是简单插入排序经过改进之后的一个**更高效的版本，**也称为**缩小增量排序**。

希尔排序法基本思想

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

![image-20211007205030775](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211007205030775.png)

![image-20211007205059415](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211007205059415.png)

希尔排序法应用实例

1. 希尔排序时，对有序序列在插入时采用**交换法**，并测试排序速度
2. 希尔排序时，对有序序列在插入时采用**移动法**，并测试排序速度

代码实现

```Java
public class ShellSort {
    public static void main(String[] args) {
//        int[] arr = {8,9,1,7,2,3,5,4,6,0};
        int[] arr = new int[80000];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int)(Math.random()*8000000);
        }
        Date date = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH-mm-ss");
        String format = simpleDateFormat.format(date);
//        System.out.println("排序前"+ Arrays.toString(arr));
        System.out.println(format);

//        shellSort(arr); //交换式
        shellSort2(arr); //移位式

        Date date1 = new Date();
        String format1 = simpleDateFormat.format(date1);
//        System.out.println("排序后"+Arrays.toString(arr));
        System.out.println(format1);
    }
    
    //希尔排序的推导过程
    public static void shellSort(int[] arr){
        int temp = 0;
        int count = 0;
        for (int gap = arr.length/2; gap > 0; gap /= 2) {
            for (int i = gap; i < arr.length; i++) {
                //遍历各组中所有的元素（共gap组，每组有个元素），步长gap
                for (int j = i - gap; j >= 0; j -= gap) {
                    //如果当前元素大于加上步长后的那个元素，说明交换
                    if (arr[j] > arr[j+gap]){
                        temp = arr[j];
                        arr[j] = arr[j+gap];
                        arr[j+gap] = temp;
                    }
                }
            }
//            System.out.println("第"+ ++count +"轮" + Arrays.toString(arr));
        }
        /*
        //希尔排序的第一轮排序
        //第一轮排序，是将10个数据分成了5组
        for (int i = 5; i < arr.length; i++) {
            //遍历各组中所有的元素（共5组，每组有两个元素），步长5
            for (int j = i - 5; j >= 0; j -= 5) {
                //如果当前元素大于加上步长后的那个元素，说明交换
                if (arr[j] > arr[j+5]){
                    temp = arr[j];
                    arr[j] = arr[j+5];
                    arr[j+5] = temp;
                }
            }
        }
        System.out.println("一轮后："+ Arrays.toString(arr));

        //希尔排序的第2轮排序
        //第2轮排序，是将10个数据分成了5/2 = 2组
        for (int i = 2; i < arr.length; i++) {
            //遍历各组中所有的元素（共2组，每组有5个元素），步长2
            for (int j = i - 2; j >= 0; j -= 2) {
                //如果当前元素大于加上步长后的那个元素，说明交换
                if (arr[j] > arr[j+2]){
                    temp = arr[j];
                    arr[j] = arr[j+2];
                    arr[j+2] = temp;
                }
            }
        }
        System.out.println("二轮后："+ Arrays.toString(arr));

        //希尔排序的第3轮排序
        //第3轮排序，是将10个数据分成了2/2 = 1组
        for (int i = 1; i < arr.length; i++) {
            //遍历各组中所有的元素（共1组）
            for (int j = i - 1; j >= 0; j -= 1) {
                //如果当前元素大于加上步长后的那个元素，说明交换
                if (arr[j] > arr[j+1]){
                    temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        System.out.println("三轮后："+ Arrays.toString(arr));
        
         */
    }

    //对交换式的希尔排序进行优化 ->移位法
    public static void shellSort2(int[] arr){

        //增量gap，并逐步的缩小增量
        for (int gap = arr.length/2; gap > 0; gap /= 2) {
            //从第gap个元素，逐个对其所在的组进行直接插入
            for (int i = gap; i < arr.length; i++) {
                int j = i;
                int temp = arr[j];
                if (arr[j] < arr[j - gap]){
                    while (j - gap >= 0 && temp < arr[j - gap]){
                        //移动
                        arr[j] = arr[j - gap];
                        j -= gap;
                    }
                    //当退出while后，就给temp找到插入的位置
                    arr[j] = temp;
                }
            }
        }
    }
}
```

#### 快速排序

快速排序法介绍：

快速排序是对**冒泡排序**的一种改进。**基本思想**：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，**整个排序过程可以递归进行**，依次达到整个数据变成有序序列。

思路分析

<img src="C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211009195055343.png" alt="image-20211009195055343" style="zoom: 67%;" />

说明

1. 如果取消左右递归，结果是 -9 -567  0 23 78 70
2. 如果取消右递归，结果是 -567 -9 0 23 78 70
3. 如果取消左递归，结果是 -9 -567 0 23 70 78

代码实现

```Java
public class QuickSort {
    public static void main(String[] args) {
//        int[] arr = {-9,78,0,23,-567,70,1,-66,56,-99};

        int[] arr = new int[80000];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int)(Math.random()*8000000);
        }
        Date date = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH-mm-ss");
        String format = simpleDateFormat.format(date);
//        System.out.println("排序前"+ Arrays.toString(arr));
        System.out.println(format);

        quickSort(arr,0,arr.length-1);

        Date date1 = new Date();
        String format1 = simpleDateFormat.format(date1);
//        System.out.println("排序后"+Arrays.toString(arr));
        System.out.println(format1);

//        System.out.println(Arrays.toString(arr));
    }
    public static void quickSort(int[] arr, int left ,int right){
        int l = left; //左下标
        int r = right; //右下表
        //pivot 中轴
        int pivot = arr[(left + right) / 2];
        int temp = 0;
        //while循环的目的是让比pivot 值小的放到左边
        //比pivot 值大的放到右边
        while ( l < r ){
            //在pivot的左边一直找，找到大于等于pivot的值,才退出
            while (arr[l] < pivot){
                l += 1;
            }
            //在pivot的右边一直找，找到小于等于pivot的值,才退出
            while (arr[r] > pivot){
                r -= 1;
            }
            //如果l >= r 说明pivot 的左右两边的值，已经按照左边全部是小于等于pivot的值
            //右边全部是大于等于pivot的值
            if ( l >= r){
                break;
            }

            //交换
            temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;

            //如果交换完后，发现这个arr[l] == pivot r-- 前移
            if (arr[l] == pivot){
                r -= 1;
            }
            //如果交换完后，发现这个arr[r] == pivot l++ 后移
            if (arr[r] == pivot){
                l += 1;
            }
        }

        //如果l == r，必须l++，r--，否则会出现栈溢出
        if (l == r){
            l += 1;
            r -= 1;
        }
        //向左递归
        if (left < r){
            quickSort(arr,left,r);
        }
        //向右递归
        if (right > l){
            quickSort(arr, l, right);
        }
    }
}
```

#### 归并排序

**归并排序介绍**

归并排序是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**策略（分治法将问题分成一些小的问题然后递归求解，而**治**的阶段则将分的阶段得到的各答案”修补“在一起，即分而治之。）

![image-20211117201946530](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211117201946530.png)

![image-20211117201852528](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211117201852528.png)

代码实现

```java
public class MergeSort {
    public static void main(String[] args) {
        int[] arr = {8,4,5,7,1,3,6,2};
        /*int[] arr = new int[80000];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int)(Math.random()*8000000);
        }
        Date date = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH-mm-ss");
        String format = simpleDateFormat.format(date);
        System.out.println(format);*/

        int[] temp = new int[arr.length];  //归并排序需要一个额外的空间
        mergeSort(arr,0,arr.length-1,temp);

        /*Date date1 = new Date();
        String format1 = simpleDateFormat.format(date1);
        System.out.println(format1);*/

        System.out.println(Arrays.toString(arr));
    }
    //分+合方法
    public static void mergeSort(int[] arr,int left,int right,int[] temp){
        if (left < right){
            int mid = (left + right) / 2; //中间索引
            //向左递归进行分解
            mergeSort(arr,left,mid,temp);
            //向右递归进行分解
            mergeSort(arr,mid+1,right,temp);
            //到合并
            merge(arr,left,mid,right,temp);
        }
    }
    //合并的方法
    /**
     *
     * @param arr   排序的数组
     * @param left  左边有序序列的初始索引
     * @param mid    中间索引
     * @param right  右边索引
     * @param temp    做中转的数组
     */
    public static void merge(int[] arr,int left,int mid,int right,int[] temp){
        int i = left;  //初始化i，左边有序序列的初始索引
        int j = mid + 1;  //初始化j，右边有序序列的初始索引
        int t = 0;  //  指向temp数组的当前索引

        // 一
        //先把左右两边（有序）的数据按照规则填充到temp数组中
        //直到左右两边的有序序列，有一边处理完毕为止
        while (i <= mid && j <= right){
            //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素
            //将左边的当前元素  拷贝到temp数组
            //然后 t++  i++
            if (arr[i] <= arr[j]){
                temp[t] = arr[i];
                t += 1;
                i += 1;
            } else {  //反之
                temp[t] = arr[j];
                t += 1;
                j += 1;
            }

        }
        //（二）
        //把有剩余数据的一边的数据依次全部填充到temp
        while (i <= mid){  //左边的有序序列还有剩余的元素，全部填充到temp
            temp[t] = arr[i];
            t++;
            i++;
        }
        while (j <= right){  //右边的有序序列还有剩余的元素，全部填充到temp
            temp[t] = arr[j];
            t++;
            j++;
        }

        //（三）
        //将temp数组的元素拷贝到arr
        //注意： 并不是每次都拷贝所有
        t = 0;
        int tempLeft = left;  //
        //第一次合并 tempLeft = 0，right = 1
        //          tempLeft = 2，right = 3
        //          tempLeft = 0，right = 3
        //最后一次   tempLeft = 0，right = 7

//        System.out.println("tempLeft=" + tempLeft + "right = " + right);

        while (tempLeft <= right){
            arr[tempLeft] = temp[t];
            t += 1;
            tempLeft += 1;
        }
    }
}
```

#### **常用排序算法总结和对比**



![image-20211117213827482](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211117213827482.png)

#### 基数排序

基数排序（桶排序）介绍：

1. **基数排序**属于“分配式排序”，又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的**元素分配**至某些“桶”中，达到排序的作用
2. 基数排序法是属于稳定性的排序，基数排序法是效率高的稳定性排序法
3. 基数排序是**桶排序**的扩展
4. 基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。

基数排序基本思想

​	    **将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。**

![image-20211118163534786](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211118163534786.png)

![image-20211118163610323](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211118163610323.png)

![image-20211118163647661](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211118163647661.png)

代码实现

```java
public class RadixSort {
    public static void main(String[] args) {
//        int[] arr = new int[8000000];
//        for (int i = 0; i < arr.length; i++) {
//            arr[i] = (int)(Math.random()*8000000);
//        }
//        Date date = new Date();
//        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH-mm-ss");
//        String format = simpleDateFormat.format(date);
//        System.out.println(format);

        int[] arr = {53,3,542,748,14,214};
        radixSort(arr);

//        Date date1 = new Date();
//        String format1 = simpleDateFormat.format(date1);
//        System.out.println(format1);

//        System.out.println(Arrays.toString(arr));
    }

    //基数排序方法
    public static void radixSort(int[] arr){
        
        //定义一个二维数组，表示10个桶，每个桶就是一个一维数组
        //说明
        // 1. 二维数组包含10个一维数组
        // 2. 为了防止在放入数的时候，数据溢出，则每个一维数组（桶），大小定位arr.length
        // 3. 基数排序是使用空间换时间的经典算法
        int[][] bucket = new int[10][arr.length];

        //为了记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数
        //可以这样理解
        //比如： bucketElementCounts[0]，记录的就是 bucket[0] 桶的放入数据个数
        int[] bucketElementCounts = new int[10];

        //根据下面的推导过程，可以得到最终的基数排序代码

        //1. 得到数组中最大的数的位数
        int max = arr[0];  //假设第一个数就是最大数
        for (int i = 1; i < arr.length; i++) {
            if (max < arr[i]){
                max = arr[i];
            }
        }
        //得到最大数是几位数
        int maxLength = (max + "").length();

        for (int i = 0,n = 1; i < maxLength; i++,n *= 10) {
            //针对每个元素对应的位数进行排序处理，第一次是个位，第二次是十位，第三次是百位 ...
            for (int j = 0; j < arr.length; j++) {
                //取出每个元素第i位数的值
                int digitOfElement = (arr[j]/n) % 10;
                //放入到对应的桶中
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }
            //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）
            int index = 0;
            //遍历每一个桶，并将桶中数据，放入原来数组
            for (int k = 0; k < bucketElementCounts.length; k++) {
                //如果桶中有数据，才放入到原数组
                if (bucketElementCounts[k] != 0){
                    //循环该桶 -->  即第k个桶   放入
                    for (int l = 0; l < bucketElementCounts[k]; l++) {
                        //取出元素放入到arr
                        arr[index++] = bucket[k][l];
                    }
                }
                //第一轮处理后，需要将每个 bucketElementCounts[k] = 0 !!!!
                bucketElementCounts[k] = 0;
            }
//            System.out.println("第"+(i+1)+"轮，对个位的排序处理"+ Arrays.toString(arr));
        }
        /*//第一轮（针对每个元素的各位进行排序处理）
        for (int j = 0; j < arr.length; j++) {

            //取出每个元素的个位的值
            int digitOfElement = arr[j] % 10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            bucketElementCounts[digitOfElement]++;
        }
        //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）
        int index = 0;
        //遍历每一个桶，并将桶中数据，放入原来数组
        for (int k = 0; k < bucketElementCounts.length; k++) {
            //如果桶中有数据，才放入到原数组
            if (bucketElementCounts[k] != 0){
                //循环该桶 -->  即第k个桶   放入
                for (int l = 0; l < bucketElementCounts[k]; l++) {
                    //取出元素放入到arr
                    arr[index++] = bucket[k][l];
                }
            }
            //第一轮处理后，需要将每个 bucketElementCounts[k] = 0 !!!!
            bucketElementCounts[k] = 0;
        }

        System.out.println("第1轮，对个位的排序处理"+ Arrays.toString(arr));

        //第2轮（针对每个元素的各位进行排序处理）
        for (int j = 0; j < arr.length; j++) {

            //取出每个元素的十位的值
            int digitOfElement = arr[j]/10 % 10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            bucketElementCounts[digitOfElement]++;
        }
        //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）
        index = 0;
        //遍历每一个桶，并将桶中数据，放入原来数组
        for (int k = 0; k < bucketElementCounts.length; k++) {
            //如果桶中有数据，才放入到原数组
            if (bucketElementCounts[k] != 0){
                //循环该桶 -->  即第k个桶   放入
                for (int l = 0; l < bucketElementCounts[k]; l++) {
                    //取出元素放入到arr
                    arr[index++] = bucket[k][l];
                }
            }
            //第二轮处理后，需要将每个 bucketElementCounts[k] = 0 !!!!
            bucketElementCounts[k] = 0;
        }

        System.out.println("第2轮，对个位的排序处理"+ Arrays.toString(arr));

        //第3轮（针对每个元素的各位进行排序处理）
        for (int j = 0; j < arr.length; j++) {

            //取出每个元素的百位的值
            int digitOfElement = arr[j] / 100 % 10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            bucketElementCounts[digitOfElement]++;
        }
        //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）
        index = 0;
        //遍历每一个桶，并将桶中数据，放入原来数组
        for (int k = 0; k < bucketElementCounts.length; k++) {
            //如果桶中有数据，才放入到原数组
            if (bucketElementCounts[k] != 0){
                //循环该桶 -->  即第k个桶   放入
                for (int l = 0; l < bucketElementCounts[k]; l++) {
                    //取出元素放入到arr
                    arr[index++] = bucket[k][l];
                }
            }
        }

        System.out.println("第3轮，对个位的排序处理"+ Arrays.toString(arr));*/
    }
}
```



基数排序的说明：

1. 基数排序是对传统桶排序的扩展，速度很快
2. 基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成OutOfMemoryError。
3. 基数排序是稳定的。【假定在待排序的记录序列中，存在多个具有相同关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中 r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，**则称这种排序算法是稳定的，否则称为不稳定的**】
4. **有负数的数组，不要用基数排序来进行排序**

## 查找算法

介绍

在java中 常用的查找有四种

1. 顺序(线性)查找
2. 二分查找/折半查找
3. 插值查找
4. 斐波那契查找

### 二分查找

思路分析

![image-20211125144158909](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211125144158909.png)

简单实现  没有相同的数值 的查找

```java
//使用二分查找的前提，该数组是有序的
public class BinarySearch {
    public static void main(String[] args) {
        int[] arr = {1,8,10,89,1000,1000,1000,1000,1234};
//        int index = binarySearch(arr,0,arr.length-1,1000);
        List<Integer> resList = binarySearch2(arr,0,arr.length-1,1000);
        System.out.println(resList);
    }

    /**
     *
     * @param arr 数组
     * @param left 左边的索引
     * @param right 右边的索引
     * @param findVal 要查找的值
     * @return 如果找到返回下标  没有找到返回 -1
     */
    public static int binarySearch(int[] arr,int left,int right,int findVal){
        //当left ＞ right时，说明递归整个数组也没有找到
        if (left > right){
            return -1;
        }
        int mid = (left + right)/2;
        int midVal = arr[mid];

        if (findVal > midVal){ //向右递归
            return binarySearch(arr,mid+1,right,findVal);
        }else if (findVal < midVal){ //向左递归
            return binarySearch(arr,left,mid-1,findVal);
        }else {
            return mid;
        }
    }

    /**
     * 思考题：{1，8，10，89，1000，1000，1234} 当一个有序数组中，
     *  有多个相同的数值时，如何将所有的数值都查找到，比如这里的1000
     *
     *  思路分析
     *  1.再找到mid的索引值，不要马上返回
     *  2.向mid  索引值的左边扫描，将所有满足1000  的元素下标，加入到ArrayList
     *  3.向mid  索引值的右边扫描，将所有满足1000  的元素下标，加入到ArrayList
     *  4.将ArrayList返回
     */
    public static ArrayList<Integer> binarySearch2(int[] arr, int left, int right, int findVal){
        //当left ＞ right时，说明递归整个数组也没有找到
        if (left > right){
            return new ArrayList<>();
        }
        int mid = (left + right)/2;
        int midVal = arr[mid];

        if (findVal > midVal){ //向右递归
            return binarySearch2(arr,mid+1,right,findVal);
        }else if (findVal < midVal){ //向左递归
            return binarySearch2(arr,left,mid-1,findVal);
        }else {
//            思路分析
//            1.再找到mid的索引值，不要马上返回
//            2.向mid  索引值的左边扫描，将所有满足1000  的元素下标，加入到ArrayList
//            3.向mid  索引值的右边扫描，将所有满足1000  的元素下标，加入到ArrayList
//            4.将ArrayList返回
            ArrayList<Integer> resIndexList = new ArrayList<>();
            int temp = mid - 1;
            while (true){
                if (temp < 0||arr[temp] != findVal){  //退出
                    break;
                }
                //否则，将temp 放入到 resIndexList中
                resIndexList.add(temp);
                temp -= 1;  //temp左移

            }
            resIndexList.add(mid);
            //向mid  索引值的右边扫描，将所有满足1000  的元素下标，加入到ArrayList
            temp = mid + 1;
            while (true){
                if (temp > arr.length-1 ||arr[temp] != findVal){  //退出
                    break;
                }
                //否则，将temp 放入到 resIndexList中
                resIndexList.add(temp);
                temp += 1;  //temp左移

            }
            return resIndexList;
        }
    }
}
```

### 插值查找算法

![image-20211125155716013](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211125155716013.png)



```java
public class InsertValueSearch {
    public static void main(String[] args) {
        int[] arr = new int[100];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i + 1;
        }
        int index = insertValueSearch(arr,0,arr.length-1,100);
        System.out.println(index);
    }
    /**
     * 插值查找算法
     *  arr 数组
     *  left 左边索引
     *  right 右边索引
     *  findVal 查找值
     * @return 如果找到，就返回对应的下标，没有找到 就返回-1
     */
    public static int insertValueSearch(int[] arr,int left,int right,int findVal){
        //findVal < arr[0] 和 findVal > arr[arr.length-1] 必须需要
        //否则我们得到的mid 可能越界
        if (left > right || findVal < arr[0]||findVal > arr[arr.length-1]){
            return -1;
        }

        //求出mid 自适应
        int mid = left + (right - left)*(findVal - arr[left])/(arr[right]-arr[left]);
        int midVal = arr[mid];
        if (findVal > midVal){  //向右递归
            return insertValueSearch(arr,mid + 1,right,findVal);
        }else if (findVal < midVal){
            return insertValueSearch(arr,left,mid-1,findVal);
        }else {
            return mid;
        }
    }
}
```

插值查找注意事项：

1. 对于数据量较大，**关键字分布比较均匀**的查找表来说，采用**插值查找，速度较快**
2. 关键字分布不均匀的情况下，该方法不一定比二分查找要好。

### 斐波那契(黄金分割法)查找算法

斐波那契(黄金分割法)查找基本介绍:

1) 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。
2) **斐波那契数列{1,1,2,3,5,8,13,21,34,55}**发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618

![image-20211207105650866](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211207105650866.png)

![image-20211207105716634](C:\Users\牛牛牛\AppData\Roaming\Typora\typora-user-images\image-20211207105716634.png)

